// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'loyalty_attribute_container_dto.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

LoyaltyAttributeContainerDTO _$LoyaltyAttributeContainerDTOFromJson(
    Map<String, dynamic> json) {
  return _LoyaltyAttributeContainerDTO.fromJson(json);
}

/// @nodoc
mixin _$LoyaltyAttributeContainerDTO {
  @JsonKey(name: 'LoyaltyAttributeId')
  int get loyaltyAttributeId => throw _privateConstructorUsedError;
  @JsonKey(name: 'Attribute')
  String get attribute => throw _privateConstructorUsedError;
  @JsonKey(name: 'PurchaseApplicable')
  String get purchaseApplicable => throw _privateConstructorUsedError;
  @JsonKey(name: 'ConsumptionApplicable')
  String get consumptionApplicable => throw _privateConstructorUsedError;
  @JsonKey(name: 'DBColumnName')
  String get dBColumnName => throw _privateConstructorUsedError;
  @JsonKey(name: 'CreditPlusType')
  String get creditPlusType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LoyaltyAttributeContainerDTOCopyWith<LoyaltyAttributeContainerDTO>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoyaltyAttributeContainerDTOCopyWith<$Res> {
  factory $LoyaltyAttributeContainerDTOCopyWith(
          LoyaltyAttributeContainerDTO value,
          $Res Function(LoyaltyAttributeContainerDTO) then) =
      _$LoyaltyAttributeContainerDTOCopyWithImpl<$Res,
          LoyaltyAttributeContainerDTO>;
  @useResult
  $Res call(
      {@JsonKey(name: 'LoyaltyAttributeId') int loyaltyAttributeId,
      @JsonKey(name: 'Attribute') String attribute,
      @JsonKey(name: 'PurchaseApplicable') String purchaseApplicable,
      @JsonKey(name: 'ConsumptionApplicable') String consumptionApplicable,
      @JsonKey(name: 'DBColumnName') String dBColumnName,
      @JsonKey(name: 'CreditPlusType') String creditPlusType});
}

/// @nodoc
class _$LoyaltyAttributeContainerDTOCopyWithImpl<$Res,
        $Val extends LoyaltyAttributeContainerDTO>
    implements $LoyaltyAttributeContainerDTOCopyWith<$Res> {
  _$LoyaltyAttributeContainerDTOCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loyaltyAttributeId = null,
    Object? attribute = null,
    Object? purchaseApplicable = null,
    Object? consumptionApplicable = null,
    Object? dBColumnName = null,
    Object? creditPlusType = null,
  }) {
    return _then(_value.copyWith(
      loyaltyAttributeId: null == loyaltyAttributeId
          ? _value.loyaltyAttributeId
          : loyaltyAttributeId // ignore: cast_nullable_to_non_nullable
              as int,
      attribute: null == attribute
          ? _value.attribute
          : attribute // ignore: cast_nullable_to_non_nullable
              as String,
      purchaseApplicable: null == purchaseApplicable
          ? _value.purchaseApplicable
          : purchaseApplicable // ignore: cast_nullable_to_non_nullable
              as String,
      consumptionApplicable: null == consumptionApplicable
          ? _value.consumptionApplicable
          : consumptionApplicable // ignore: cast_nullable_to_non_nullable
              as String,
      dBColumnName: null == dBColumnName
          ? _value.dBColumnName
          : dBColumnName // ignore: cast_nullable_to_non_nullable
              as String,
      creditPlusType: null == creditPlusType
          ? _value.creditPlusType
          : creditPlusType // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LoyaltyAttributeContainerDTOCopyWith<$Res>
    implements $LoyaltyAttributeContainerDTOCopyWith<$Res> {
  factory _$$_LoyaltyAttributeContainerDTOCopyWith(
          _$_LoyaltyAttributeContainerDTO value,
          $Res Function(_$_LoyaltyAttributeContainerDTO) then) =
      __$$_LoyaltyAttributeContainerDTOCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: 'LoyaltyAttributeId') int loyaltyAttributeId,
      @JsonKey(name: 'Attribute') String attribute,
      @JsonKey(name: 'PurchaseApplicable') String purchaseApplicable,
      @JsonKey(name: 'ConsumptionApplicable') String consumptionApplicable,
      @JsonKey(name: 'DBColumnName') String dBColumnName,
      @JsonKey(name: 'CreditPlusType') String creditPlusType});
}

/// @nodoc
class __$$_LoyaltyAttributeContainerDTOCopyWithImpl<$Res>
    extends _$LoyaltyAttributeContainerDTOCopyWithImpl<$Res,
        _$_LoyaltyAttributeContainerDTO>
    implements _$$_LoyaltyAttributeContainerDTOCopyWith<$Res> {
  __$$_LoyaltyAttributeContainerDTOCopyWithImpl(
      _$_LoyaltyAttributeContainerDTO _value,
      $Res Function(_$_LoyaltyAttributeContainerDTO) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? loyaltyAttributeId = null,
    Object? attribute = null,
    Object? purchaseApplicable = null,
    Object? consumptionApplicable = null,
    Object? dBColumnName = null,
    Object? creditPlusType = null,
  }) {
    return _then(_$_LoyaltyAttributeContainerDTO(
      loyaltyAttributeId: null == loyaltyAttributeId
          ? _value.loyaltyAttributeId
          : loyaltyAttributeId // ignore: cast_nullable_to_non_nullable
              as int,
      attribute: null == attribute
          ? _value.attribute
          : attribute // ignore: cast_nullable_to_non_nullable
              as String,
      purchaseApplicable: null == purchaseApplicable
          ? _value.purchaseApplicable
          : purchaseApplicable // ignore: cast_nullable_to_non_nullable
              as String,
      consumptionApplicable: null == consumptionApplicable
          ? _value.consumptionApplicable
          : consumptionApplicable // ignore: cast_nullable_to_non_nullable
              as String,
      dBColumnName: null == dBColumnName
          ? _value.dBColumnName
          : dBColumnName // ignore: cast_nullable_to_non_nullable
              as String,
      creditPlusType: null == creditPlusType
          ? _value.creditPlusType
          : creditPlusType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_LoyaltyAttributeContainerDTO implements _LoyaltyAttributeContainerDTO {
  const _$_LoyaltyAttributeContainerDTO(
      {@JsonKey(name: 'LoyaltyAttributeId')
          required this.loyaltyAttributeId,
      @JsonKey(name: 'Attribute')
          required this.attribute,
      @JsonKey(name: 'PurchaseApplicable')
          required this.purchaseApplicable,
      @JsonKey(name: 'ConsumptionApplicable')
          required this.consumptionApplicable,
      @JsonKey(name: 'DBColumnName')
          required this.dBColumnName,
      @JsonKey(name: 'CreditPlusType')
          required this.creditPlusType});

  factory _$_LoyaltyAttributeContainerDTO.fromJson(Map<String, dynamic> json) =>
      _$$_LoyaltyAttributeContainerDTOFromJson(json);

  @override
  @JsonKey(name: 'LoyaltyAttributeId')
  final int loyaltyAttributeId;
  @override
  @JsonKey(name: 'Attribute')
  final String attribute;
  @override
  @JsonKey(name: 'PurchaseApplicable')
  final String purchaseApplicable;
  @override
  @JsonKey(name: 'ConsumptionApplicable')
  final String consumptionApplicable;
  @override
  @JsonKey(name: 'DBColumnName')
  final String dBColumnName;
  @override
  @JsonKey(name: 'CreditPlusType')
  final String creditPlusType;

  @override
  String toString() {
    return 'LoyaltyAttributeContainerDTO(loyaltyAttributeId: $loyaltyAttributeId, attribute: $attribute, purchaseApplicable: $purchaseApplicable, consumptionApplicable: $consumptionApplicable, dBColumnName: $dBColumnName, creditPlusType: $creditPlusType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LoyaltyAttributeContainerDTO &&
            (identical(other.loyaltyAttributeId, loyaltyAttributeId) ||
                other.loyaltyAttributeId == loyaltyAttributeId) &&
            (identical(other.attribute, attribute) ||
                other.attribute == attribute) &&
            (identical(other.purchaseApplicable, purchaseApplicable) ||
                other.purchaseApplicable == purchaseApplicable) &&
            (identical(other.consumptionApplicable, consumptionApplicable) ||
                other.consumptionApplicable == consumptionApplicable) &&
            (identical(other.dBColumnName, dBColumnName) ||
                other.dBColumnName == dBColumnName) &&
            (identical(other.creditPlusType, creditPlusType) ||
                other.creditPlusType == creditPlusType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, loyaltyAttributeId, attribute,
      purchaseApplicable, consumptionApplicable, dBColumnName, creditPlusType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LoyaltyAttributeContainerDTOCopyWith<_$_LoyaltyAttributeContainerDTO>
      get copyWith => __$$_LoyaltyAttributeContainerDTOCopyWithImpl<
          _$_LoyaltyAttributeContainerDTO>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LoyaltyAttributeContainerDTOToJson(
      this,
    );
  }
}

abstract class _LoyaltyAttributeContainerDTO
    implements LoyaltyAttributeContainerDTO {
  const factory _LoyaltyAttributeContainerDTO(
          {@JsonKey(name: 'LoyaltyAttributeId')
              required final int loyaltyAttributeId,
          @JsonKey(name: 'Attribute')
              required final String attribute,
          @JsonKey(name: 'PurchaseApplicable')
              required final String purchaseApplicable,
          @JsonKey(name: 'ConsumptionApplicable')
              required final String consumptionApplicable,
          @JsonKey(name: 'DBColumnName')
              required final String dBColumnName,
          @JsonKey(name: 'CreditPlusType')
              required final String creditPlusType}) =
      _$_LoyaltyAttributeContainerDTO;

  factory _LoyaltyAttributeContainerDTO.fromJson(Map<String, dynamic> json) =
      _$_LoyaltyAttributeContainerDTO.fromJson;

  @override
  @JsonKey(name: 'LoyaltyAttributeId')
  int get loyaltyAttributeId;
  @override
  @JsonKey(name: 'Attribute')
  String get attribute;
  @override
  @JsonKey(name: 'PurchaseApplicable')
  String get purchaseApplicable;
  @override
  @JsonKey(name: 'ConsumptionApplicable')
  String get consumptionApplicable;
  @override
  @JsonKey(name: 'DBColumnName')
  String get dBColumnName;
  @override
  @JsonKey(name: 'CreditPlusType')
  String get creditPlusType;
  @override
  @JsonKey(ignore: true)
  _$$_LoyaltyAttributeContainerDTOCopyWith<_$_LoyaltyAttributeContainerDTO>
      get copyWith => throw _privateConstructorUsedError;
}
